//! SysCallMeMaybe Policy Merger
//!
//! Merges multiple YAML policy files into a single unified policy.
//! Useful when recording the same binary under different conditions
//! and combining the extracted policies.
//!
//! # Usage
//!
//! ```bash
//! scmm-merge -i policy1.yaml -i policy2.yaml -o merged.yaml
//! ```

use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::process::ExitCode;

use anyhow::{Context, Result};
use clap::Parser;
use tracing::info;

use scmm_common::policy::YamlPolicy;

mod merge;

/// SysCallMeMaybe (SCMM) - Policy merger
///
/// Merges multiple YAML policies into a single unified policy (union of all rules).
#[derive(Parser, Debug)]
#[command(name = "scmm-merge")]
#[command(author, version, about, long_about = None)]
#[command(after_help = "SCMM stands for SysCallMeMaybe - a Linux syscall sandboxing suite.")]
struct Args {
    /// Input YAML policy files (specify multiple with -i file1 -i file2 ...)
    #[arg(short, long, required = true, num_args = 1)]
    input: Vec<PathBuf>,

    /// Output merged policy file
    #[arg(short, long, default_value = "merged-policy.yaml")]
    output: PathBuf,

    /// Name for the merged policy
    #[arg(long)]
    name: Option<String>,

    /// Verbose output
    #[arg(short, long, action = clap::ArgAction::Count)]
    verbose: u8,
}

fn main() -> ExitCode {
    let args = Args::parse();

    scmm_common::init_tracing(args.verbose);

    match run(args) {
        Ok(()) => ExitCode::SUCCESS,
        Err(e) => {
            eprintln!("Error: {:#}", e);
            ExitCode::FAILURE
        }
    }
}

fn run(args: Args) -> Result<()> {
    info!("SysCallMeMaybe Policy Merger");

    if args.input.len() < 2 {
        anyhow::bail!("At least 2 input policies are required (got {})", args.input.len());
    }

    // Read all input policies
    let mut policies = Vec::with_capacity(args.input.len());
    for path in &args.input {
        info!("Reading policy from: {}", path.display());
        let mut file = File::open(path)
            .with_context(|| format!("Failed to open policy file: {}", path.display()))?;
        let mut yaml_content = String::new();
        file.read_to_string(&mut yaml_content)?;
        let policy: YamlPolicy = serde_yaml::from_str(&yaml_content)
            .with_context(|| format!("Failed to parse YAML policy: {}", path.display()))?;
        info!(
            "  {} â€” {} syscall rules, {} filesystem rules",
            policy.metadata.name,
            policy.syscalls.len(),
            policy.filesystem.rules.len()
        );
        policies.push(policy);
    }

    // Merge
    let input_names: Vec<String> = args
        .input
        .iter()
        .map(|p| p.display().to_string())
        .collect();
    let merged = merge::merge_policies(policies, args.name.as_deref(), &input_names)?;

    info!(
        "Merged policy: {} syscall rules, {} filesystem rules, {} capabilities",
        merged.syscalls.len(),
        merged.filesystem.rules.len(),
        merged.capabilities.len()
    );

    // Write output
    info!("Writing merged policy to: {}", args.output.display());
    let yaml = serde_yaml::to_string(&merged).context("Failed to serialize merged policy")?;

    let header = "# SysCallMeMaybe (SCMM) Merged Policy File\n\
                  # Generated by scmm-merge\n\
                  #\n\
                  # Use 'scmm-compile' to compile this policy for enforcement:\n\
                  #   scmm-compile -i merged-policy.yaml -o policy.scmm-pol\n\
                  #\n";

    let mut out = File::create(&args.output).context("Failed to create output file")?;
    std::io::Write::write_all(&mut out, header.as_bytes())?;
    std::io::Write::write_all(&mut out, yaml.as_bytes())?;

    println!(
        "Merged {} policies into: {}",
        input_names.len(),
        args.output.display()
    );

    Ok(())
}
